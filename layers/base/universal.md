<!-- GENERATED BY claude-docs compose.sh — do not edit directly -->

# Universal Engineering Standards

Stack-agnostic principles and expectations that apply to every project regardless of technology. Technology-specific layers build on these — they do not override them.

---

## Coding Philosophy

Write code for humans first, machines second.

- **Readability over cleverness.** If a solution requires a comment to explain what it does, simplify the solution. Never use obscure language features, bitwise tricks, or dense one-liners to save a few lines.
- **Simplicity over abstraction.** Do not introduce abstractions until a pattern repeats at least three times. Premature abstraction creates more complexity than duplication. Prefer composition over inheritance.
- **Consistency over personal preference.** Follow established conventions even when you disagree. Consistency across a codebase matters more than any individual stylistic improvement. If a convention needs changing, change it everywhere or not at all.
- **Explicit over implicit.** Avoid hidden side effects, magic strings, implicit type conversions, and convention-based wiring that requires tribal knowledge to understand.
- **Small, focused units.** Functions do one thing. Modules have one responsibility. If you struggle to name something, it probably does too much.

## Naming Conventions

Names are the most important form of documentation. A well-named variable, function, or module eliminates the need for comments.

### General Rules

- Use descriptive, unambiguous names. `remainingAttempts` not `cnt`. `customerEmailAddress` not `email`.
- Do not abbreviate unless the abbreviation is universally understood in the domain (e.g., `id`, `url`, `http`).
- Booleans use affirmative prefixes: `isActive`, `hasPermission`, `canExecute`. Never negate the name — use `isValid` and negate at the call site.
- Collections use plural nouns: `customers`, `orderItems`, `activeSubscriptions`.
- Constants use `UPPER_SNAKE_CASE`.

### Database

- Table names: `snake_case`, plural: `customers`, `order_items`, `subscription_plans`.
- Column names: `snake_case`, singular: `first_name`, `created_at`, `is_active`.
- Foreign keys: `referenced_table_singular_id`: `customer_id`, `order_id`.
- Indexes: `idx_tablename_columns`: `idx_customers_email`.
- Constraints: `chk_tablename_description` for checks, `uq_tablename_columns` for unique constraints.
- Join tables: alphabetical combination of both table names: `customers_roles`.

## Package-by-Feature Architecture

All code for a business feature lives in one directory: request handlers, business logic, data access, data transfer objects, mapping logic, errors, and tests. This is non-negotiable.

```
src/
├── billing/          # Everything for billing: handlers, service, data access, DTOs, errors
├── customer/         # Everything for customer management
└── common/           # Shared code used by three or more features only
```

Features communicate through public service interfaces — never by accessing another feature's data layer directly. If Feature A needs data from Feature B, Feature A calls Feature B's service.

`common` is for genuinely cross-cutting code (base entity, error response, pagination). If something is used by only two features, put it in the feature that owns the concept.

## Git Conventions

### Commit Messages

Use the Conventional Commits format:

```
type(scope): short description

Longer explanation if needed. Explain why, not what.
The diff shows what changed; the message explains the motivation.

Closes #123
```

**Types:** `feat`, `fix`, `refactor`, `test`, `docs`, `chore`, `perf`, `ci`, `build`.

**Scope:** The feature or area affected: `feat(billing): add invoice PDF generation`.

**Rules:** imperative mood, lowercase, no period, max 72 characters subject. Body wraps at 80 characters. One logical change per commit — do not mix refactoring with feature work.

**Branches:** `main` (protected, always deployable), `feature/{id}-{desc}`, `fix/{id}-{desc}`. Rebase before merging, keep history linear.

**PRs:** reviewable in under 30 minutes. Title follows commit format. Description: what changed, why, how to test, migration steps. Passing CI required.

## Claude Code Behaviour

### Ask vs. Act

- **Act immediately** for: implementing features, fixing bugs, adding tests, creating migrations — any task with unambiguous requirements.
- **Ask first** for: architectural decisions affecting multiple features, choosing between approaches, deleting or significantly restructuring existing code, adding new dependencies, altering public API contracts.
- When in doubt, bias towards acting. Working code is faster to review than hypotheticals.

### Code Generation

Complete, runnable code only — no `// TODO: implement this` placeholders. Include all imports. Follow project conventions exactly; do not introduce alternatives you prefer. Generate all files for a feature together, never partial features.

### Explaining Work

Do not explain generated code unless it departs from conventions. For debugging: step-by-step reasoning. For architecture: state trade-offs. Two-sentence rationale beats a five-paragraph essay.

### Handling Uncertainty

Follow the existing codebase pattern when CLAUDE.md doesn't cover a situation. Never silently assume business logic — ask when domain rules are ambiguous. Technical choices (algorithm, data structure, library API): use judgement and explain if non-obvious.

### Language

Use British English in all communication, comments, and documentation: `colour`, `organised`, `behaviour`, `authorisation`. Technical identifiers and third-party API names retain their original spelling.

## Testing Philosophy

Every feature ships with tests. Tests are the specification — they document what the code does and catch regressions.

Test every public service function (happy path, validation, edge cases, errors), every API endpoint (parsing, validation, response structure, status codes), every complex mapping, and every non-trivial query. **Do not** test trivial accessors, framework behaviour, private functions, or generated code.

**Patterns:** Arrange-Act-Assert structure with clear visual separation. One assertion per test concept. Descriptive test names that convey what is being tested, the conditions, and the expected outcome. Test data builders — never construct complex objects inline in test functions. No test interdependence.

**Mocking:** Mock external boundaries (HTTP clients, message queues, email senders, file systems). Prefer real infrastructure over mocks for data stores and brokers — real tests catch real bugs. Prefer fakes over mocks when the fake is simple to implement.

## Error Handling

Errors are a first-class concern. Handle them explicitly, consistently, and informatively.

- Use specific error types for specific conditions: `CustomerNotFoundError`, `InvoiceAlreadyPaidError`.
- Never use generic error types. Never use errors for flow control — use return values for expected conditions.
- Maintain a small set of categories: **not found** (404), **validation** (400), **business rule** (422), **authentication** (401), **authorisation** (403), **integration** (502). Unhandled errors → 500, never exposing internals.

Every API error response follows this structure:

```json
{
  "error": {
    "code": "CUSTOMER_NOT_FOUND",
    "message": "Customer with ID 'abc-123' was not found",
    "details": [],
    "timestamp": "2025-01-15T10:30:00Z",
    "traceId": "req-xyz-789"
  }
}
```

## Logging

Use structured logging. Propagate correlation identifiers (traceId, tenantId) in every log entry via your framework's context mechanism. Log levels: **INFO** for significant operation entry/exit with identifiers; **ERROR** for failures with full context; **WARN** for recovered unexpected conditions; **DEBUG** for diagnostic detail (off in production). Never log passwords, tokens, API keys, PII, or full request/response bodies at INFO.

## Documentation

Comments explain **why**, not what. If code needs a comment to explain what it does, refactor it. Mark `// HACK:`, `// FIXME:`, `// TODO:` with a ticket reference — never without one. Every project has a README covering: what it is, local setup, testing, deployment, and key architectural decisions.

## Security

- Validate all input at API boundaries: type, format, length, range. Apply business rule validation in the service layer after sanitisation.
- Never construct SQL, HTML, XML, or JSON by string concatenation. Use parameterised queries, template engines, and serialisation libraries.
- Every endpoint is authenticated by default. Mark exceptions explicitly (health checks, public assets).
- Use established identity providers and standards (OAuth2/OIDC). Never implement custom authentication. Validate tokens on every request.
- Encrypt sensitive data at rest. HTTPS everywhere. Least privilege for services and database users. Vulnerability scans in CI. Pin dependency versions — no dynamic ranges in production.
